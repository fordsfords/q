<!DOCTYPE html><html><head><title>q_h.txt</title>
<link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
<script src="//code.jquery.com/jquery-1.10.2.js"></script>
<script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
<script>
  $(function() {
    $( document ).tooltip();
  });
</script>
<style>
#code {background-color:#ffffff;};
</style>
</head>
<body><h1>q_h.txt</h1>
<script>hljs.initHighlightingOnLoad();</script>
<small><pre><code id="code"><table border=0 cellpadding=0 cellspacing=0><tr>
<td>00001
00002
00003
00004
00005
00006
00007
00008
00009
00010
00011
00012
00013
00014
00015
00016
00017
00018
00019
00020
00021
<a href="q.sldoc.html#q_t_ref_1" target="doc">00022</a>
<a href="q.sldoc.html#q_t_ref_1" target="doc">00023</a>
00024
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00025</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00026</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00027</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00028</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00029</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00030</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00031</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00032</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00033</a>
<a href="q.sldoc.html#qerr_defs_ref_1" target="doc">00034</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00035</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00036</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00037</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00038</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00039</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00040</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00041</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00042</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00043</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00044</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00045</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00046</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00047</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00048</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00049</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00050</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00051</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00052</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00053</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00054</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00055</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00056</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00057</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00058</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00059</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00060</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00061</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00062</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00063</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00064</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00065</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00066</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00067</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00068</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00069</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00070</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00071</a>
<a href="q.sldoc.html#apis_ref_1" target="doc">00072</a>
00073
00074
00075
00076
00077
00078
</td><td>  /* q.h - lock-free, non-blocking message queue.  See https://github.com/fordsfords/q/tree/gh-pages */
  
  /* This work is dedicated to the public domain under CC0 1.0 Universal:
   * http://creativecommons.org/publicdomain/zero/1.0/
   * 
   * To the extent possible under law, Steven Ford has waived all copyright
   * and related or neighboring rights to this work. In other words, you can 
   * use this code for any purpose without any restrictions.
   * This work is published from: United States.
   * Project home: https://github.com/fordsfords/q
   */
  
  #ifndef Q_H
  #define Q_H
  
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  typedef unsigned int qerr_t;     /* see QERR_* definitions above */
  
<span name="q_t" id="q_t"></span>  struct q_s;                       /* forward (opaque) definition */
  typedef struct q_s q_t;           /* object type of queue instance */
  
<span name="qerr_defs" id="qerr_defs"></span>  /* Most q APIs return "qerr_t".  These definitions must
   * be kept in sync with the "qerrs" string array in "q.c". */
  #define QERR_OK 0         /* Success */
  #define QERR_BUG1 1       /* Internal software bug - should never happen */
  #define QERR_BUG2 2       /* Internal software bug - should never happen */
  #define QERR_BADSIZE 3    /* q_size parameter invalid */
  #define QERR_MALLOCERR 4  /* No memory available */
  #define QERR_FULL 5       /* No room in queue */
  #define QERR_EMPTY 6      /* No messages in queue */
  #define LAST_QERR 6   /* Set to value of last "QERR_*" definition */
  
  qerr_t q_create(q_t **rtn_q, unsigned int q_size);
  /* Create an instance of a queue.
   * rtn_q  : Pointer to caller's queue instance handle.
   * q_size : Number of queue elements to allocate.  Must be &gt; 1 and a power
   *          of 2.  Due to the nature of the algorithm used, a maximum of
   *          q_size - 1 elements can actually be stored in the queue.
   * Returns QERR_OK on success, or other QERR_* value on error. */
  
  qerr_t q_delete(q_t *q);
  /* Delete an instance of a queue.
   * q : Queue instance handle.
   * Returns QERR_OK on success, or other QERR_* value on error. */
  
  qerr_t q_enq( q_t *q, void *m);
  /* Add a message to the queue.
   * q : Queue instance handle.
   * m : Message to enqueue.
   * Returns QERR_OK on success, QERR_FULL if queue full, or other QERR_* value on error. */
  
  qerr_t q_deq(q_t *q, void **rtn_m);
  /* Remove a message from the queue.
   * q     : Queue instance handle.
   * rtn_m : Pointer to caller's message handle.
   * Returns QERR_OK on success, QERR_EMPTY if queue empty, or other QERR_* value on error. */
  
  int q_is_empty(q_t *q);
  /* Returns 1 if queue is empty (contains no messages), 0 otherwise.
   * q : Queue instance handle. */
  
  int q_is_full(q_t *q);
  /* Returns 1 if queue is full (contains q_size-1 message), 0 otherwise.
   * q : Queue instance handle. */
  
  char *q_qerr_str(qerr_t qerr);
  /* Returns a string representation of a queue API return error code.
   * qerr : value returned by most q APIs indicating success or faiure.
   * (See q.h for list of QERR_* definitions.) */
  
  #ifdef __cplusplus
  }
  #endif
  
  #endif  /* Q_H */
</td></tr></table></code>




















































































</pre></small></body></html>
