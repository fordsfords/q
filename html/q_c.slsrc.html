<!DOCTYPE html><html><head><title>q_c.txt</title>
<link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
<script src="//code.jquery.com/jquery-1.10.2.js"></script>
<script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
<script>
  $(function() {
    $( document ).tooltip();
  });
</script>
<style>
#code {background-color:#ffffff;};
</style>
</head>
<body><h1>q_c.txt</h1>
<script>hljs.initHighlightingOnLoad();</script>
<small><pre><code id="code"><table border=0 cellpadding=0 cellspacing=0><tr>
<a name="inc_selftest_h" id="inc_selftest_h"></a><a name="fence_def" id="fence_def"></a><a name="qerr_strs" id="qerr_strs"></a><a name="q_s" id="q_s"></a><a name="pad" id="pad"></a><a name="qerr_chk" id="qerr_chk"></a><a name="alloc_msgs" id="alloc_msgs"></a><a name="fence_set" id="fence_set"></a><a name="fence_chk" id="fence_chk"></a><a name="enqueue" id="enqueue"></a><a name="tailcalc" id="tailcalc"></a><a name="dequeue" id="dequeue"></a><a name="headcalc" id="headcalc"></a><a name="inc_selftest_c" id="inc_selftest_c"></a><td>00001
00002
00003
00004
00005
00006
00007
00008
00009
00010
00011
00012
00013
00014
00015
00016
00017
00018
00019
00020
00021
00022
00023
<a href="q.sldoc.html#inc_selftest_h_ref_1" target="doc">00024</a>
<a href="q.sldoc.html#inc_selftest_h_ref_1" target="doc">00025</a>
<a href="q.sldoc.html#inc_selftest_h_ref_1" target="doc">00026</a>
<a href="q.sldoc.html#inc_selftest_h_ref_1" target="doc">00027</a>
00028
00029
00030
<a href="q.sldoc.html#fence_def_ref_1" target="doc">00031</a>
00032
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00033</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00034</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00035</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00036</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00037</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00038</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00039</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00040</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00041</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00042</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00043</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00044</a>
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00045</a>
00046
00047
<a href="q.sldoc.html#q_s_ref_1" target="doc">00048</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00049</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00050</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00051</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00052</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00053</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00054</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00055</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00056</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00057</a>
<a href="q.sldoc.html#pad_ref_1" target="doc">00058</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00059</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00060</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00061</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00062</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00063</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00064</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00065</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00066</a>
<a href="q.sldoc.html#q_s_ref_1" target="doc">00067</a>
00068
00069
00070
00071
00072
00073
00074
00075
00076
00077
00078
00079
00080
00081
00082
00083
00084
00085
00086
00087
00088
00089
<a href="q.sldoc.html#qerr_chk_ref_1" target="doc">00090</a>
<a href="q.sldoc.html#qerr_chk_ref_1" target="doc">00091</a>
00092
00093
00094
00095
00096
00097
00098
00099
00100
00101
<a href="q.sldoc.html#alloc_msgs_ref_1" target="doc">00102</a>
<a href="q.sldoc.html#alloc_msgs_ref_1" target="doc">00103</a>
<a href="q.sldoc.html#alloc_msgs_ref_1" target="doc">00104</a>
00105
00106
<a href="q.sldoc.html#fence_set_ref_1" target="doc">00107</a>
00108
00109
00110
00111
00112
00113
00114
00115
00116
00117
00118
00119
00120
00121
00122
00123
00124
00125
00126
00127
00128
00129
<a href="q.sldoc.html#fence_chk_ref_1" target="doc">00130</a>
00131
00132
00133
00134
00135
00136
00137
00138
00139
00140
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00141</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00142</a>
<a href="q.sldoc.html#tailcalc_ref_1" target="doc">00143</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00144</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00145</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00146</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00147</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00148</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00149</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00150</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00151</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00152</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00153</a>
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00154</a>
00155
00156
00157
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00158</a>
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00159</a>
<a href="q.sldoc.html#headcalc_ref_1" target="doc">00160</a>
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00161</a>
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00162</a>
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00163</a>
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00164</a>
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00165</a>
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00166</a>
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00167</a>
00168
00169
00170
00171
00172
00173
00174
00175
00176
00177
00178
00179
00180
00181
00182
00183
00184
00185
00186
<a href="q.sldoc.html#inc_selftest_c_ref_1" target="doc">00187</a>
<a href="q.sldoc.html#inc_selftest_c_ref_1" target="doc">00188</a>
<a href="q.sldoc.html#inc_selftest_c_ref_1" target="doc">00189</a>
<a href="q.sldoc.html#inc_selftest_c_ref_1" target="doc">00190</a>
</td><td>  /* q.c - lock-free, non-blocking message queue.  See https://github.com/fordsfords/q/tree/gh-pages */
  /*
  # This code and its documentation is Copyright 2014, 2015 Steven Ford, http://geeky-boy.com
  # and licensed "public domain" style under Creative Commons "CC0": http://creativecommons.org/publicdomain/zero/1.0/
  # To the extent possible under law, the contributors to this project have
  # waived all copyright and related or neighboring rights to this work.
  # In other words, you can use this code for any purpose without any
  # restrictions.  This work is published from: United States.  The project home
  # is https://github.com/fordsfords/q/tree/gh-pages
  */
  /* Although the code contained herein was written from scratch by Steve Ford in 2014,
   * the algorithm was influenced by John D. Valois' 1994 paper:
   *     "Implementing Lock-Free Queues"
   * http://people.cs.pitt.edu/~jacklange/teaching/cs2510-f12/papers/implementing_lock_free.pdf
   *     Valois, J.: Implementing lock-free queues. In: Proceedings of the Seventh
   *     International Conference on Parallel and Distributed Computing Systems. (1994) 64â€“69
   *
   * See q.h file for details on the API functions.
   */
  
  #include &lt;stdlib.h&gt;
  #include &lt;pthread.h&gt;
  
  /* If built with "-DSELFTEST" then include extras for unit testing. */
  #ifdef SELFTEST
  #  include "q_selftest.h"
  #endif
  
  #include "q.h"
  
  #define Q_FENCE 0x7d831f20   /* used for testing (random number generated at random.org) */
  
  /* This list of strings must be kept in sync with the
   * corresponding "QERR_*" constant definitions in "q.h".
   * It is used by the q_qerr_str() function. */
  static char *qerrs[] = {
      "QERR_OK",
      "QERR_BUG1",
      "QERR_BUG2",
      "QERR_BADSIZE",
      "QERR_MALLOCERR",
      "QERR_FULL",
      "QERR_EMPTY",
      "BAD_QERR", NULL};
  #define BAD_QERR (sizeof(qerrs)/sizeof(qerrs[0]) - 2)
  
  
  /* message element */
  struct q_msg_s {
      void *d;
      int in_use;
  };
  typedef struct q_msg_s q_msg_t;
  
  /* q.h contains an empty forward definition of "q_s", and defines "q_t" */
  struct q_s {
      unsigned int enq_cnt;     /* count of successful messages enqueued (tail pointer) */
      char enq_pad[CACHE_LINE_SIZE - (sizeof(unsigned int))];  /* align next var on cache line */
  
      unsigned int deq_cnt;     /* count of successful messages dequeued (head pointer) */
      char deq_pad[CACHE_LINE_SIZE - (sizeof(unsigned int))];  /* align next var on cache line */
  
      q_msg_t * volatile msgs;  /* Array of "q_size" elements */
      unsigned int size_mask;  /* Number of msgs elements minus 1 */
      /* make total size a multiple of cache line size, to prevent interference with whatever comes after */
      char final_pad[CACHE_LINE_SIZE - ( sizeof(unsigned int) + sizeof(void **) )];
  };  /* struct q_s */
  
  
  /* Internal function: return 1 if power of 2 */
  static int is_power_2(unsigned int n)
  {
      /* Thanks to Alex Allain at http://www.cprogramming.com/tutorial/powtwosol.html for this cute algo. */
      return ((n-1) &amp; n) == 0;
  }  /* is_power_2 */
  
  
  /* See q.h for doc */
  char *q_qerr_str(qerr_t qerr)
  {
      if (qerr &gt;= BAD_QERR) { return qerrs[BAD_QERR]; }  /* bad qerr */
  
      return qerrs[qerr];
  }  /* q_qerr_str */
  
  
  /* See q.h for doc */
  qerr_t q_create(q_t **rtn_q, unsigned int q_size)
  {
      /* Sanity check the error code definitions and strings */
      if (LAST_QERR != BAD_QERR - 1) { return QERR_BUG1; }  /* the QERR_* are out of sync with qerrs[] */
      if (sizeof(q_t) % CACHE_LINE_SIZE != 0) { return QERR_BUG2; }  /* q_t not multiple of cache line size */
  
      /* Sanity check input size */
      if (q_size &lt;= 1 || ! is_power_2(q_size)) { return QERR_BADSIZE; }
  
      /* Create queue object instance */
      q_t *q = NULL;
      int perr = posix_memalign((void **)&amp;q, CACHE_LINE_SIZE, sizeof(*q));
      if (perr != 0 || q == NULL) { return QERR_MALLOCERR; }
  
      /* Allocate message storage array (one extra unused element for fence) */
      q-&gt;msgs = NULL;
      perr = posix_memalign((void **)&amp;q-&gt;msgs, CACHE_LINE_SIZE, (q_size + 1) * sizeof(q-&gt;msgs[0]) );
      if (perr != 0 || q-&gt;msgs == NULL) { free(q);  return QERR_MALLOCERR; }
  
      q-&gt;msgs[q_size].d = (void *)Q_FENCE;  /* used by unit tests to insure no overflow */
  
      /* empty the queue */
      unsigned int i;
      for (i = 0; i &lt; q_size; i++) {
          q-&gt;msgs[i].in_use = 0;
      }
  
      q-&gt;enq_cnt = 0;  /* Init the queue counters */
      q-&gt;deq_cnt = 0;
  
      q-&gt;size_mask = q_size - 1;  /* bit mask to "and" enq_cnt and deq_cnt to get tail and head */
  
      /* Success */
      *rtn_q = q;
      return QERR_OK;
  }  /* q_create */
  
  
  /* See q.h for doc */
  qerr_t q_delete(q_t *q)
  {
      /* Quick sanity check to make sure the queue didn't overflow */
      if (q-&gt;msgs[q-&gt;size_mask + 1].d != (void *)Q_FENCE) { return QERR_BUG1; }
      q-&gt;msgs[q-&gt;size_mask + 1].d = NULL;  /* remove fence to maybe detect double-delete */
  
      free((void *)q-&gt;msgs);
      free(q);
  
      return QERR_OK;
  }  /* q_delete */
  
  
  /* See q.h for doc */
  qerr_t q_enq(q_t *q, void *m)
  {
      unsigned int tail = (unsigned)(q-&gt;enq_cnt &amp; q-&gt;size_mask);
  
      /* Queue must always have at least one empty slot.  Make sure that
       * after the current tail is filled, the next slot will be empty. */
      unsigned int next_tail = (tail + 1) &amp; q-&gt;size_mask;
      if (q-&gt;msgs[next_tail].in_use) { return QERR_FULL; }  /* Queue is full, item not added */
  
      q-&gt;msgs[tail].d = (void * volatile)m;
      q-&gt;msgs[tail].in_use = 1;
      q-&gt;enq_cnt++;
      return QERR_OK;
  }  /* q_enq */
  
  
  /* See q.h for doc */
  qerr_t q_deq(q_t *q, void **rtn_m)
  {
      unsigned int head = (unsigned)(q-&gt;deq_cnt &amp; q-&gt;size_mask);
      if (! q-&gt;msgs[head].in_use) { return QERR_EMPTY; }
  
      *rtn_m = (void *)q-&gt;msgs[head].d;
      q-&gt;msgs[head].in_use = 0;  /* mark it as empty */
      q-&gt;deq_cnt++;
      return QERR_OK;
  }  /* q_deq */
  
  
  /* See q.h for doc */
  int q_is_empty(q_t *q)
  {
      unsigned int head = (unsigned)(q-&gt;deq_cnt &amp; q-&gt;size_mask);
      return (! q-&gt;msgs[head].in_use);
  }  /* q_is_empty */
  
  
  /* See q.h for doc */
  int q_is_full(q_t *q)
  {
      unsigned int tail = (unsigned)(q-&gt;enq_cnt &amp; q-&gt;size_mask);
      unsigned int next_tail = (tail + 1) &amp; q-&gt;size_mask;
      return (q-&gt;msgs[next_tail].in_use);
  }  /* q_is_full */
  
  
  /* If built with "-DSELFTEST" then include main() for unit testing. */
  #ifdef SELFTEST
  #include "q_selftest.c"
  #endif
</td></tr></table></code></pre></small></body></html>
