<html><head><title>q_c.txt</title></head>
<html><head><title>q_c.txt</title></head>
<body><h1>q_c.txt</h1>
<p><em>Hint:</em> do not cut-and-paste from this page.  Instead, right-click on '<a href="q_c.txt">q_c.txt</a>' and save file.
<small><pre>
00001  /* q.c - lock-free, non-blocking message queue.  See http://geeky-boy.com/q/ */
00002  /*
00003  # This code and its documentation is Copyright 2014 Steven Ford, sford@geeky-boy.com
00004  # and licensed under Creative Commons "CC0": http://creativecommons.org/publicdomain/zero/1.0/
00005  # To the extent possible under law, Steve Ford has waived all copyright and related or
00006  # neighboring rights to this work.  This work is published from: United States.
00007  */
00008  /* Although the code contained herein was written from scratch by Steve Ford in 2014,
00009   * the algorithm was influenced by John D. Valois' 1994 paper:
00010   *     "Implementing Lock-Free Queues"
00011   * http://people.cs.pitt.edu/~jacklange/teaching/cs2510-f12/papers/implementing_lock_free.pdf
00012   *     Valois, J.: Implementing lock-free queues. In: Proceedings of the Seventh
00013   *     International Conference on Parallel and Distributed Computing Systems. (1994) 64â€“69
00014   *
00015   * See q.h file for details on the API functions.
00016   */
00017  
00018  #include &lt;stdlib.h&gt;
00019  #include &lt;pthread.h&gt;
00020  
<a name="inc_selftest_h" id="inc_selftest_h"></a><a href="q.sldoc.html#inc_selftest_h_ref_1" target="doc">00021</a>  /* If built with "-DSELFTEST" then include extras for unit testing. */
<a href="q.sldoc.html#inc_selftest_h_ref_1" target="doc">00022</a>  #ifdef SELFTEST
<a href="q.sldoc.html#inc_selftest_h_ref_1" target="doc">00023</a>  #  include "q_selftest.h"
<a href="q.sldoc.html#inc_selftest_h_ref_1" target="doc">00024</a>  #endif
00025  
00026  #include "q.h"
00027  
<a name="fence_def" id="fence_def"></a><a href="q.sldoc.html#fence_def_ref_1" target="doc">00028</a>  #define Q_FENCE 0x7d831f20   /* used for testing (random number generated at random.org) */
00029  
<a name="qerr_strs" id="qerr_strs"></a><a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00030</a>  /* This list of strings must be kept in sync with the
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00031</a>   * corresponding "QERR_*" constant definitions in "q.h".
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00032</a>   * It is used by the q_qerr_str() function. */
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00033</a>  static char *qerrs[] = {
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00034</a>      "QERR_OK",
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00035</a>      "QERR_BUG1",
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00036</a>      "QERR_BUG2",
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00037</a>      "QERR_BADSIZE",
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00038</a>      "QERR_MALLOCERR",
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00039</a>      "QERR_FULL",
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00040</a>      "QERR_EMPTY",
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00041</a>      "BAD_QERR", NULL};
<a href="q.sldoc.html#qerr_strs_ref_1" target="doc">00042</a>  #define BAD_QERR (sizeof(qerrs)/sizeof(qerrs[0]) - 2)
00043  
00044  
<a name="q_s" id="q_s"></a><a href="q.sldoc.html#q_s_ref_1" target="doc">00045</a>  /* message element */
<a href="q.sldoc.html#q_s_ref_1" target="doc">00046</a>  struct q_msg_s {
<a href="q.sldoc.html#q_s_ref_1" target="doc">00047</a>      void *d;
<a href="q.sldoc.html#q_s_ref_1" target="doc">00048</a>      int in_use;
<a href="q.sldoc.html#q_s_ref_1" target="doc">00049</a>  };
<a href="q.sldoc.html#q_s_ref_1" target="doc">00050</a>  typedef struct q_msg_s q_msg_t;
<a href="q.sldoc.html#q_s_ref_1" target="doc">00051</a>  
<a href="q.sldoc.html#q_s_ref_1" target="doc">00052</a>  /* q.h contains an empty forward definition of "q_s", and defines "q_t" */
<a href="q.sldoc.html#q_s_ref_1" target="doc">00053</a>  struct q_s {
<a href="q.sldoc.html#q_s_ref_1" target="doc">00054</a>      unsigned int enq_cnt;     /* count of successful messages enqueued (tail pointer) */
<a name="pad" id="pad"></a><a href="q.sldoc.html#pad_ref_1" target="doc">00055</a>      char enq_pad[CACHE_LINE_SIZE - (sizeof(unsigned int))];  /* align next var on cache line */
<a href="q.sldoc.html#q_s_ref_1" target="doc">00056</a>  
<a href="q.sldoc.html#q_s_ref_1" target="doc">00057</a>      unsigned int deq_cnt;     /* count of successful messages dequeued (head pointer) */
<a href="q.sldoc.html#q_s_ref_1" target="doc">00058</a>      char deq_pad[CACHE_LINE_SIZE - (sizeof(unsigned int))];  /* align next var on cache line */
<a href="q.sldoc.html#q_s_ref_1" target="doc">00059</a>  
<a href="q.sldoc.html#q_s_ref_1" target="doc">00060</a>      q_msg_t * volatile msgs;  /* Array of "q_size" elements */
<a href="q.sldoc.html#q_s_ref_1" target="doc">00061</a>      unsigned int size_mask;  /* Number of msgs elements minus 1 */
<a href="q.sldoc.html#q_s_ref_1" target="doc">00062</a>      /* make total size a multiple of cache line size, to prevent interference with whatever comes after */
<a href="q.sldoc.html#q_s_ref_1" target="doc">00063</a>      char final_pad[CACHE_LINE_SIZE - ( sizeof(unsigned int) + sizeof(void **) )];
<a href="q.sldoc.html#q_s_ref_1" target="doc">00064</a>  };  /* struct q_s */
00065  
00066  
00067  /* Internal function: return 1 if power of 2 */
00068  static int is_power_2(unsigned int n)
00069  {
00070      /* Thanks to Alex Allain at http://www.cprogramming.com/tutorial/powtwosol.html for this cute algo. */
00071      return ((n-1) &amp; n) == 0;
00072  }  /* is_power_2 */
00073  
00074  
00075  /* See q.h for doc */
00076  char *q_qerr_str(qerr_t qerr)
00077  {
00078      if (qerr &gt;= BAD_QERR) { return qerrs[BAD_QERR]; }  /* bad qerr */
00079  
00080      return qerrs[qerr];
00081  }  /* q_qerr_str */
00082  
00083  
00084  /* See q.h for doc */
00085  qerr_t q_create(q_t **rtn_q, unsigned int q_size)
00086  {
<a name="qerr_chk" id="qerr_chk"></a><a href="q.sldoc.html#qerr_chk_ref_1" target="doc">00087</a>      /* Sanity check the error code definitions and strings */
<a href="q.sldoc.html#qerr_chk_ref_1" target="doc">00088</a>      if (LAST_QERR != BAD_QERR - 1) { return QERR_BUG1; }  /* the QERR_* are out of sync with qerrs[] */
00089      if (sizeof(q_t) % CACHE_LINE_SIZE != 0) { return QERR_BUG2; }  /* q_t not multiple of cache line size */
00090  
00091      /* Sanity check input size */
00092      if (q_size &lt;= 1 || ! is_power_2(q_size)) { return QERR_BADSIZE; }
00093  
00094      /* Create queue object instance */
00095      q_t *q = NULL;
00096      int perr = posix_memalign((void **)&amp;q, CACHE_LINE_SIZE, sizeof(*q));
00097      if (perr != 0 || q == NULL) { return QERR_MALLOCERR; }
00098  
<a name="alloc_msgs" id="alloc_msgs"></a><a href="q.sldoc.html#alloc_msgs_ref_1" target="doc">00099</a>      /* Allocate message storage array (one extra unused element for fence) */
<a href="q.sldoc.html#alloc_msgs_ref_1" target="doc">00100</a>      q-&gt;msgs = NULL;
<a href="q.sldoc.html#alloc_msgs_ref_1" target="doc">00101</a>      perr = posix_memalign((void **)&amp;q-&gt;msgs, CACHE_LINE_SIZE, (q_size + 1) * sizeof(q-&gt;msgs[0]) );
00102      if (perr != 0 || q-&gt;msgs == NULL) { free(q);  return QERR_MALLOCERR; }
00103  
<a name="fence_set" id="fence_set"></a><a href="q.sldoc.html#fence_set_ref_1" target="doc">00104</a>      q-&gt;msgs[q_size].d = (void *)Q_FENCE;  /* used by unit tests to insure no overflow */
00105  
00106      /* empty the queue */
00107      unsigned int i;
00108      for (i = 0; i &lt; q_size; i++) {
00109          q-&gt;msgs[i].in_use = 0;
00110      }
00111  
00112      q-&gt;enq_cnt = 0;  /* Init the queue counters */
00113      q-&gt;deq_cnt = 0;
00114  
00115      q-&gt;size_mask = q_size - 1;  /* bit mask to "and" enq_cnt and deq_cnt to get tail and head */
00116  
00117      /* Success */
00118      *rtn_q = q;
00119      return QERR_OK;
00120  }  /* q_create */
00121  
00122  
00123  /* See q.h for doc */
00124  qerr_t q_delete(q_t *q)
00125  {
00126      /* Quick sanity check to make sure the queue didn't overflow */
<a name="fence_chk" id="fence_chk"></a><a href="q.sldoc.html#fence_chk_ref_1" target="doc">00127</a>      if (q-&gt;msgs[q-&gt;size_mask + 1].d != (void *)Q_FENCE) { return QERR_BUG1; }
00128      q-&gt;msgs[q-&gt;size_mask + 1].d = NULL;  /* remove fence to maybe detect double-delete */
00129  
00130      free((void *)q-&gt;msgs);
00131      free(q);
00132  
00133      return QERR_OK;
00134  }  /* q_delete */
00135  
00136  
00137  /* See q.h for doc */
<a name="enqueue" id="enqueue"></a><a href="q.sldoc.html#enqueue_ref_1" target="doc">00138</a>  qerr_t q_enq(q_t *q, void *m)
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00139</a>  {
<a name="tailcalc" id="tailcalc"></a><a href="q.sldoc.html#tailcalc_ref_1" target="doc">00140</a>      unsigned int tail = (unsigned)(q-&gt;enq_cnt &amp; q-&gt;size_mask);
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00141</a>  
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00142</a>      /* Queue must always have at least one empty slot.  Make sure that
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00143</a>       * after the current tail is filled, the next slot will be empty. */
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00144</a>      unsigned int next_tail = (tail + 1) &amp; q-&gt;size_mask;
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00145</a>      if (q-&gt;msgs[next_tail].in_use) { return QERR_FULL; }  /* Queue is full, item not added */
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00146</a>  
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00147</a>      q-&gt;msgs[tail].d = (void * volatile)m;
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00148</a>      q-&gt;msgs[tail].in_use = 1;
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00149</a>      q-&gt;enq_cnt++;
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00150</a>      return QERR_OK;
<a href="q.sldoc.html#enqueue_ref_1" target="doc">00151</a>  }  /* q_enq */
00152  
00153  
00154  /* See q.h for doc */
<a name="dequeue" id="dequeue"></a><a href="q.sldoc.html#dequeue_ref_1" target="doc">00155</a>  qerr_t q_deq(q_t *q, void **rtn_m)
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00156</a>  {
<a name="headcalc" id="headcalc"></a><a href="q.sldoc.html#headcalc_ref_1" target="doc">00157</a>      unsigned int head = (unsigned)(q-&gt;deq_cnt &amp; q-&gt;size_mask);
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00158</a>      if (! q-&gt;msgs[head].in_use) { return QERR_EMPTY; }
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00159</a>  
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00160</a>      *rtn_m = (void *)q-&gt;msgs[head].d;
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00161</a>      q-&gt;msgs[head].in_use = 0;  /* mark it as empty */
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00162</a>      q-&gt;deq_cnt++;
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00163</a>      return QERR_OK;
<a href="q.sldoc.html#dequeue_ref_1" target="doc">00164</a>  }  /* q_deq */
00165  
00166  
00167  /* See q.h for doc */
00168  int q_is_empty(q_t *q)
00169  {
00170      unsigned int head = (unsigned)(q-&gt;deq_cnt &amp; q-&gt;size_mask);
00171      return (! q-&gt;msgs[head].in_use);
00172  }  /* q_is_empty */
00173  
00174  
00175  /* See q.h for doc */
00176  int q_is_full(q_t *q)
00177  {
00178      unsigned int tail = (unsigned)(q-&gt;enq_cnt &amp; q-&gt;size_mask);
00179      unsigned int next_tail = (tail + 1) &amp; q-&gt;size_mask;
00180      return (q-&gt;msgs[next_tail].in_use);
00181  }  /* q_is_full */
00182  
00183  
<a name="inc_selftest_c" id="inc_selftest_c"></a><a href="q.sldoc.html#inc_selftest_c_ref_1" target="doc">00184</a>  /* If built with "-DSELFTEST" then include main() for unit testing. */
<a href="q.sldoc.html#inc_selftest_c_ref_1" target="doc">00185</a>  #ifdef SELFTEST
<a href="q.sldoc.html#inc_selftest_c_ref_1" target="doc">00186</a>  #include "q_selftest.c"
<a href="q.sldoc.html#inc_selftest_c_ref_1" target="doc">00187</a>  #endif
</pre></small></body></html>
